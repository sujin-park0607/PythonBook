# 개념

- 정의 : 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 말한다.

- 특징

1. 사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형이다.
2. 문제에서 가장 큰 순서대로 혹은 가장 작은 순서대로와 같은 기준을 제시한다. 그로 인해 정렬 알고리즘과 짝을 이룬다.

# 문제 풀이

## 제목 : 큰 수의 법칙

### 문제의 아이디어 생각해낸 포인트

### 시간 복잡도 계산

### 입력

```py
# 배열의 크기 N , 숫자가 더해지는 횟수 M, K가 주어질때 동빈이의 큰 수 법칙에 따른 결과 출력

n , m , k = map(int, input().split())
arr  = list(map(int,  input().split()))
arr.sort(reverse=True)
first = arr[0]
second = arr[1]

result =0

while True :
    for i in range(k) :
        if m == 0 :
            break
        result += first
        m -= 1

    if m == 0 :
        break
    result += second
    m -= 1

print(result)

```

## 제목 : 큰 수의 법칙

### 문제의 아이디어 생각해낸 포인트

### 시간 복잡도 계산

### 입력

```py
# 배열의 크기 N , 숫자가 더해지는 횟수 M, K가 주어질때 동빈이의 큰 수 법칙에 따른 결과 출력

n , m , k = map(int, input().split())
arr  = list(map(int,  input().split()))
arr.sort(reverse=True)
first = arr[0]
second = arr[1]

result =0

while True :
    for i in range(k) :
        if m == 0 :
            break
        result += first
        m -= 1

    if m == 0 :
        break
    result += second
    m -= 1

print(result)

```

## 제목 : 큰 수의 법칙

### 문제의 아이디어 생각해낸 포인트

### 시간 복잡도 계산

### 입력

```py
# 배열의 크기 N , 숫자가 더해지는 횟수 M, K가 주어질때 동빈이의 큰 수 법칙에 따른 결과 출력

n , m , k = map(int, input().split())
arr  = list(map(int,  input().split()))
arr.sort(reverse=True)
first = arr[0]
second = arr[1]

result =0

while True :
    for i in range(k) :
        if m == 0 :
            break
        result += first
        m -= 1

    if m == 0 :
        break
    result += second
    m -= 1

print(result)

```
